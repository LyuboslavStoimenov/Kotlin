import java.lang.Exception
import kotlin.math.ceil
import kotlin.math.max
import kotlin.math.min
import kotlin.time.hours

class Time(var hours : Int, var minutes : Int){
    init{
        if(hours<0||hours>23) println("Error, there is no such time!")
        else if(minutes<0||minutes>59) println("Error, there is no such time!")

    }
}


 class ParkTicket(val entryTime: Time,var exitTime: Time? = null){

    /* fun checkIfCorrect():ParkTicket{
         var parkedHours : Int = exitTime!!.hours - entryTime.hours
         var parkedMinutes : Int = exitTime!!.minutes - entryTime.minutes
         if(parkedHours <= 0 && parkedMinutes <= 0){

         }


     }*/
     fun parkingDuration() : Int {

        if (exitTime != null) { //If exit time is diffrent from null
            var parkedHours : Int = exitTime!!.hours - entryTime.hours  //Subtract entry time from exit time
            var parkedMinutes : Int = exitTime!!.minutes - entryTime.minutes//Subtract entry mins from exit mins
            return parkedHours * 60 + parkedMinutes //return only minutes (convert hours to minutes)
        }
        else throw Exception("\"ParkTicket muss vorher korrekt abgestempelt werden!") //if exitTime = null --> return ""ParkTicket muss vorher korrekt abgestempelt werden!"
    }
    val parkingDuration : Int
        get(){
            if (exitTime!=null){
                var parkedHours : Int = exitTime!!.hours - entryTime.hours
                var parkedMinutes : Int = exitTime!!.minutes - entryTime.minutes
                return parkedHours * 60 + parkedMinutes
            }
            else throw Exception("\"ParkTicket muss vorher korrekt abgestempelt werden!")
        }
    fun hoursStarted() :Int{
        if(exitTime!=null){
            var numberHours = ceil(parkingDuration().toDouble()/60.0).toInt()
            return numberHours
        }
        else throw Exception("ParkTicket muss vorher korrekt abgestempelt werden!")
    }
    val hoursStarted : Int
        get(){
            if (exitTime!=null){
                var numberHours = ceil(parkingDuration().toDouble()/60.0).toInt()
                return numberHours
            }
            else throw Exception("ParkTicket muss vorher korrekt abgestempelt werden!")
        }
    fun checkout(exitTime: Time){
        if(exitTime.hours > this.entryTime.hours || exitTime.hours == this.entryTime.hours && exitTime.minutes>this.entryTime.minutes)
            this?.exitTime = exitTime
    }

}
enum class Tariff(var price : Double){
    DEFAULT(1.99), EVENT(1.49), WEEKEND(2.99);
    fun price():Double{
        return when(this){
            DEFAULT -> 1.99
            EVENT -> 1.49
            WEEKEND -> 2.99
        }
    }
}
class TicketMachine(var aktuellTarif: Tariff){
     var parkscheinenListe = mutableListOf<ParkTicket>()

    fun generate(entryTime: Time):ParkTicket{
        val Ticket = ParkTicket(entryTime)
        this.parkscheinenListe.add(Ticket)
        return Ticket
    }
    fun checkout(checkoutTime:Time, ticketNumber:Int){
        var validTicket = parkscheinenListe[ticketNumber] //why square brackets
        validTicket.exitTime=checkoutTime
    }
    fun shortestParkingDuration(): Int{
        var ticketCount = 0; var shortestParktime = 0; var duration = 1440; //duration = 1440 beacuse there are 1440 minutes in 24 hours
        while (ticketCount < this.parkscheinenListe.size){
            if (this.parkscheinenListe[ticketCount].exitTime !=null){
                if (this.parkscheinenListe[ticketCount].parkingDuration < duration){
                    shortestParktime = this.parkscheinenListe[ticketCount].parkingDuration
                    duration = this.parkscheinenListe[ticketCount].parkingDuration
                }
            }
            ticketCount++
        }
        return shortestParktime
    }
    fun averageParkingDuration(): Int{
        var ticketCount = 0; var currentCount = 0; var duration = 0;
        while (ticketCount < this.parkscheinenListe.size){
            if (this.parkscheinenListe[ticketCount].exitTime!=null){
                duration+=this.parkscheinenListe[ticketCount].parkingDuration
                currentCount++
            }
            ticketCount++
        }
        return duration/currentCount
    }
    fun revenues(): Double{
        var ticketCount = 0; var hours = 0;
        while (ticketCount<this.parkscheinenListe.size){
            if (this.parkscheinenListe[ticketCount].exitTime!=null){
                hours += this.parkscheinenListe[ticketCount].hoursStarted
            }
            ticketCount++
        }
        return this.aktuellTarif.price*hours.toDouble()
    }

}

fun main (){
    val machine = TicketMachine ( Tariff . DEFAULT )
    val ticket1 = machine . generate ( Time (12 , 0) )
    val ticket2 = machine . generate ( Time (12 , 30) )
    val ticket3 = machine . generate ( Time (13 , 30) )
    val ticket4 = machine . generate ( Time (13 , 30) )
    val ticket5 = machine . generate(Time(12,0))
    ticket5.exitTime = Time(10,0)
    ticket1 . checkout ( Time (12 , 30) ) // 30 min (1h)
    ticket2 . checkout ( Time (13 , 30) ) // 60 min (1h)
    ticket3 . checkout ( Time (14 , 50) ) // 80 min (2h)
// ticket4 wird nicht abgestempelt und wird daher für alle folgenden Methodenaufrufe nicht berücksichtigt
    println ( machine . shortestParkingDuration () ) // Gibt 30 aus
    println ( machine . averageParkingDuration () ) // Gibt 56 aus ((30 + 60 + 80) / 3)

    println ( machine . revenues () ) // Gibt 7.96 aus ((1 + 1 + 2) * machine . tariff . price ())


}
